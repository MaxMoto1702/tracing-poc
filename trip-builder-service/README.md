# High-level description of trip generation algorithm

Main entry point of the application is located in file `app.py`. It can serve requests via endpoints compatible with the
previous trip generation module:

1. `/api/route` REST endpoint
2. A system of 3 SQS queues (request, response and DLQ)

Each of the above invokes `legacy_build_trip` which builds a trip according to the request and converts it to the legacy
format

Also, there is `/build-trip` endpoint which returns trip in the new format. Request format is (currently) the same as
for legacy endpoints

Whichever endpoint is used, trip generation consists of two main steps:

1. `init_trip` - creates a "backbone" of each day of the trip: assigns hotel and meal time slots to the times according
   to the user request. Meal time slots at this point are not bound to any particular food places, they just serve as a
   placeholder to reserve the most appropriate time for meals. Also relax time is added to the trip. Relax time, besides
   its primary function, also serves as a division point between day time and evening
2. `build_trip` - fills the trip with places. At this step, two main goals are (i) to select the best places according
   to user preferences and (ii) to arrange them in a close-to-optimal sequence, taking into account places' open hours.
   Those goals are achieved by the following actions:

   i. First, all `usable` places of the trip's city are retrieved from the DB are sorted by *user value*. User value is
   a numeric value which signifies how interesting this particular place is deemed for this particular user. It
   aggregates all factors affecting attractiveness of the place for the user, both common (e.g. rating or priority flag)
   and user-dependent (such as match to user categories). From now on, the user value is used as a measure of how "good"
   the place is for the user. At this point, user value doesn't consider the geoposition of the place

   ii. Central daytime and evening places are selected for each day of the trip. Central daytime places are the best
   entertainment (i.e. non-food and non-hotel) places, and central evening places are the best food places

   iii. For each trip day, the timeline is filled with places in the following steps:

   a. each place's user value is adjusted to reflect if the place is already included in the trip. Currently, for places
   already in the trip the user value is set to zero 
   
   b. daytime entertainment places are sorted by user value adjusted
   by distance from the central day point. Then for each place in the list, several candidate days are generated by
   inserting the time slot with the place into each available open time between morning hotel (or breakfast) and relax
   time. The candidate with maximum happiness score is then compared with the current day and, if its happiness score is
   higher than that of the current day, from now on it is used as the current day
   
   c. for each meal time slot before relax time (currently unfilled), from all daytime food places open during 
   the time slot, the best place is chosen using user value adjusted by distance from the point preceding the meal time 
   slot
   
   d. dinner (i.e. evening meal time slot) is filled with the previously selected centrall evening (food) place

   e. evening entertainment places are sorted by user value adjusted by distance from the central evening place and
   used to fill evening open times in the same way as daytime open times were filled

# Notes for developers

## Installing project in a local developer's environment

1. Use python version compatible with that indicated in ./Dockerfile
2. Create and activate a new python [virtual environment](https://docs.python.org/3/tutorial/venv.html), e.g.:
   * `python3.7 -m venv env`
   * `source env/bin/activate`
3. Install requirements (e.g. run `pip install -r requirements.txt`)
4. Copy file `dev.env` into `.env` and update environment variables values
   1. Make sure `TRIP_GENERATION_LOGGER_RUN_DIR` contains absolute path to the same directory as in `BASE_DIR` in Columbus UI's `.env`
5. Don't forget to activate the virtual environment each time you start a new console session

## Running tests locally

```sh
pytest
```

## Running local test-driven development environment

1. Start trip-builder REST API
   1. You may want to disable queue polling as it is not needed for local tests
   2. `python app.py`
2. Install Columbus
   1. `git clone https://github.com/Unikoom/unikoom-columbus.git`
   2. Follow setup instructions in `unikoom-columbus/README.md`
3. Install and start Columbus UI
   1. `git clone https://github.com/Unikoom/unikoom-columbus-ui.git`
   2. Setup and start Columbus UI backend as outlined in `unikoom-columbus-ui/backend/README.md`
   3. Setup and start Columbus UI frontend as outlined in `unikoom-columbus-ui/frontend/README.md`

## Development workflow based on continuous trip quality control

1. Make sure you have set up your local test-driven development environment (see above how to do it)
2. Run Columbus locally and make sure that run results are visible in Columbus UI (you'll need them later)
   1. TODO: define standard run parameters
   2. See `unikoom-columbus-ui/backend/README.md` on how to run Columbus using Columbus UI
3. Run a test demonstrating the problem to be fixed
   1. Copy a failed request in `json` format into `test/integration` directory 
   2. Indicate the file name in `test.integration.app_test.AppTest.test_legacy_build_trip` test
   3. Run the test
   4. View the generated trip in Columbus UI and pinpoint the quality problem you are going to fix
4. Fix the problem
5. Rerun the test
   1. View the generated trip in Columbus UI and make sure the problem is gone and there are no new quality problems
6. Rerun Columbus locally with the same parameters as in Step 1
   1. Don't forget to restart trip-builder REST API
   2. Compare run results with results of run from Step 2 and make sure that no new quality problems were introduced